---
title: JavaScript FFI Layer
---

# JavaScript FFI Layer

The JavaScript FFI (Foreign Function Interface) Layer provides type-safe interoperability between MoonBit code and JavaScript runtimes (Node.js and browser environments). This layer enables the JavaScript backend to call JavaScript APIs, manipulate JavaScript objects, handle promises, and convert between MoonBit and JavaScript types.

For information about how this FFI layer is used in the JavaScript backend's HTTP server implementation, see [JavaScript Backend](#3.1). For details on Promise-based async operations, see [Asynchronous Operations](#3.1.1).

## Core Type System

The FFI layer is built around a small set of fundamental types that bridge MoonBit's type system with JavaScript's dynamic typing model.

```mermaid
graph TB
    subgraph "Central FFI Type"
        Value["Value<br/>(external type)"]
    end
    
    subgraph "Structured Types"
        Object["Object<br/>(struct wrapping Value)"]
        Promise["Promise<br/>(external type)"]
        Symbol["Symbol<br/>(opaque type)"]
    end
    
    subgraph "Nullability Types"
        Nullable["Nullable[T]"]
        Optional["Optional[T]"]
    end
    
    subgraph "Union Types"
        Union2["Union2[A,B]"]
        Union3["Union3[A,B,C]"]
        UnionN["Union4-8..."]
    end
    
    subgraph "Error Handling"
        Error_["Error_<br/>(suberror of Error)"]
    end
    
    subgraph "MoonBit Types"
        Bool["Bool"]
        Int["Int"]
        Double["Double"]
        String["String"]
        Array["Array[T]"]
    end
    
    Object --> Value
    Promise --> Value
    Nullable --> Value
    Optional --> Value
    Union2 --> Value
    Union3 --> Value
    UnionN --> Value
    Error_ --> Value
    
    Value -.->|"Cast trait"| Bool
    Value -.->|"Cast trait"| Int
    Value -.->|"Cast trait"| Double
    Value -.->|"Cast trait"| String
    Value -.->|"Cast trait"| Array
```

**Type System Overview**

Sources: `src/js/pkg.generated.mbti:165-198`, `src/js/pkg.generated.mbti:203-211`

### The Value Type

`Value` is the central FFI type representing any JavaScript value. It is marked as `#external`, meaning its internal representation is opaque to MoonBit code and managed by the JavaScript runtime.

```mermaid
graph LR
    subgraph "Value Type Capabilities"
        Value["Value"]
        
        TypeCheck["Type Checking<br/>is_bool()<br/>is_null()<br/>is_number()<br/>is_object()<br/>is_string()<br/>is_symbol()<br/>is_undefined()"]
        
        PropAccess["Property Access<br/>get_with_string<br/>get_with_index<br/>get_with_symbol<br/>set_with_string<br/>set_with_index<br/>set_with_symbol"]
        
        FnCall["Function Invocation<br/>apply<br/>apply_with_string<br/>apply_with_index<br/>apply_with_symbol<br/>new<br/>new_with_string"]
        
        TypeConv["Type Conversion<br/>cast<br/>cast_from<br/>Cast trait"]
        
        JsonConv["JSON Conversion<br/>from_json<br/>to_json<br/>from_json_string<br/>to_json_string"]
        
        Value --> TypeCheck
        Value --> PropAccess
        Value --> FnCall
        Value --> TypeConv
        Value --> JsonConv
    end
```

**Value Type Method Categories**

Sources: `src/js/pkg.generated.mbti:165-198`

| Method Category | Methods | Purpose |
|-----------------|---------|---------|
| Type Checking | `is_bool()`, `is_null()`, `is_number()`, `is_object()`, `is_string()`, `is_symbol()`, `is_undefined()` | Runtime type inspection |
| Property Access | `get_with_stringT`, `get_with_indexT`, `get_with_symbolT` | Read properties from JavaScript objects |
| Property Mutation | `set_with_stringT`, `set_with_indexT`, `set_with_symbolT` | Write properties to JavaScript objects |
| Function Invocation | `applyArg, Result`, `apply_with_stringArg, Result` | Call JavaScript functions |
| Constructor Invocation | `newArg, Result`, `new_with_stringArg, Result` | Create new JavaScript objects |
| Type Conversion | `castT`, `cast_fromT` | Convert between MoonBit and JavaScript types |
| JSON Interop | `from_json()`, `to_json()`, `from_json_string()`, `to_json_string()` | Parse and serialize JSON |
| Utilities | `extends()`, `to_string()` | Object manipulation and string conversion |

Sources: `src/js/pkg.generated.mbti:167-196`

### The Cast Trait

The `Cast` trait defines the protocol for type-safe conversion between MoonBit types and JavaScript values.

```mermaid
graph TB
    subgraph "Cast Trait"
        Cast["trait Cast"]
        Into["into(Value) -> Self?"]
        From["from(Self) -> Value"]
        
        Cast --> Into
        Cast --> From
    end
    
    subgraph "Implementations"
        BoolImpl["impl Cast for Bool"]
        IntImpl["impl Cast for Int"]
        DoubleImpl["impl Cast for Double"]
        StringImpl["impl Cast for String"]
        ArrayImpl["impl Cast for Array[A : Cast]"]
    end
    
    BoolImpl -.->|implements| Cast
    IntImpl -.->|implements| Cast
    DoubleImpl -.->|implements| Cast
    StringImpl -.->|implements| Cast
    ArrayImpl -.->|implements| Cast
```

**Cast Trait and Implementations**

The `Cast` trait provides two methods:
- `into(Value) -> Self?`: Attempts to convert a JavaScript value to a MoonBit type, returning `None` if the conversion fails
- `from(Self) -> Value`: Converts a MoonBit type to a JavaScript value (always succeeds)

Sources: `src/js/pkg.generated.mbti:203-211`

## JavaScript Object Interop

The `Object` type provides a high-level wrapper around `Value` specifically for working with JavaScript objects.

```mermaid
graph TB
    subgraph "Object Type Structure"
        Object["Object(Value)<br/>newtype wrapper"]
    end
    
    subgraph "Construction"
        New["Object::new()"]
        FromValue["Object::from_value(Value)<br/>returns Optional[Object]"]
        FromValueUnchecked["Object::from_value_unchecked(Value)"]
        FromIter["Object::from_iter[K,V](Iter)"]
        FromIter2["Object::from_iter2[K,V](Iter2)"]
    end
    
    subgraph "Conversion"
        ToValue["Object::to_value() -> Value"]
        Inner["Object::inner() -> Value<br/>(deprecated)"]
    end
    
    subgraph "Manipulation"
        OpGet["Object::op_get[K,V](K) -> V"]
        OpSet["Object::op_set[K,V](K, V)"]
        ExtendObject["Object::extend_object(Object) -> Object"]
        ExtendIter["Object::extend_iter[K,V](Iter)"]
        ExtendIter2["Object::extend_iter2[K,V](Iter2)"]
    end
    
    New --> Object
    FromValue --> Object
    FromValueUnchecked --> Object
    FromIter --> Object
    FromIter2 --> Object
    
    Object --> ToValue
    Object --> Inner
    
    Object --> OpGet
    Object --> OpSet
    Object --> ExtendObject
    Object --> ExtendIter
    Object --> ExtendIter2
```

**Object Type API**

Sources: `src/js/pkg.generated.mbti:45-58`

### Property Access Pattern

The `Object` type supports indexing operations through `op_get` and `op_set` methods. These are generic methods that work with any key and value types that implement the `Cast` trait.

```mermaid
sequenceDiagram
    participant Code as "MoonBit Code"
    participant Object as "Object"
    participant Value as "Value"
    participant JS as "JavaScript Runtime"
    
    Code->>Object: obj.op_get[String, Int]("count")
    Object->>Value: self.0 (unwrap Value)
    Value->>JS: get property "count"
    JS-->>Value: JavaScript value
    Value-->>Object: cast to Int
    Object-->>Code: Int result
    
    Code->>Object: obj.op_set[String, Bool]("active", true)
    Object->>Value: self.0 (unwrap Value)
    Value->>JS: set property "active" = true
    JS-->>Value: success
    Value-->>Object: done
    Object-->>Code: Unit
```

**Object Property Access Flow**

Sources: `src/js/pkg.generated.mbti:56-57`

### Object Extension Example

The `extend_object` method merges two JavaScript objects, with the second object's properties overwriting the first's.

```mermaid
graph LR
    subgraph "Object Extension"
        Obj1["Object<br/>{a:1, b:2, c:3}"]
        Obj2["Object<br/>{b:[6,7], d:44, a:55}"]
        Result["Object<br/>{a:55, b:[6,7], c:3, d:44}"]
        
        Obj1 --> Extend["extend_object()"]
        Obj2 --> Extend
        Extend --> Result
    end
```

**Object Extension Operation**

This pattern is demonstrated in `src/js/object_test.mbt:2-15`, where objects are created from JSON and then merged.

Sources: `src/js/pkg.generated.mbti:48`, `src/js/object_test.mbt:2-15`

## Nullability and Optional Values

JavaScript has two "absent value" types: `null` and `undefined`. The FFI layer provides distinct types to handle each.

| Type | JavaScript Equivalent | MoonBit Conversion | Use Case |
|------|----------------------|-------------------|----------|
| `Nullable[T]` | `null` | `from_option()`, `to_option()` | API that uses `null` for absent values |
| `Optional[T]` | `undefined` | `from_option()`, `to_option()` | API that uses `undefined` for absent values |

```mermaid
graph TB
    subgraph "MoonBit Option Type"
        Option["Option[T]<br/>Some(T) or None"]
    end
    
    subgraph "JavaScript Nullability"
        Null["null value"]
        Undefined["undefined value"]
    end
    
    subgraph "FFI Bridge Types"
        Nullable["Nullable[T]"]
        Optional["Optional[T]"]
    end
    
    Option -->|"Nullable::from_option"| Nullable
    Nullable -->|"Nullable::to_option"| Option
    Nullable -.->|represents| Null
    
    Option -->|"Optional::from_option"| Optional
    Optional -->|"Optional::to_option"| Option
    Optional -.->|represents| Undefined
```

**Nullability Type Conversions**

Sources: `src/js/pkg.generated.mbti:36-67`

### Nullable[T] API

| Method | Signature | Description |
|--------|-----------|-------------|
| `null()` | `() -> Nullable[T]` | Creates a `null` value |
| `is_null()` | `(Nullable[T]) -> Bool` | Checks if value is `null` |
| `from_option()` | `(T?) -> Nullable[T]` | Converts `Some(v)` to value, `None` to `null` |
| `to_option()` | `(Nullable[T]) -> T?` | Converts value to `Some(v)`, `null` to `None` |
| `unwrap()` | `(Nullable[T]) -> T` | Extracts value, panics if `null` |

Sources: `src/js/pkg.generated.mbti:36-43`

### Optional[T] API

| Method | Signature | Description |
|--------|-----------|-------------|
| `undefined()` | `() -> Optional[T]` | Creates an `undefined` value |
| `is_undefined()` | `(Optional[T]) -> Bool` | Checks if value is `undefined` |
| `from_option()` | `(T?) -> Optional[T]` | Converts `Some(v)` to value, `None` to `undefined` |
| `to_option()` | `(Optional[T]) -> T?` | Converts value to `Some(v)`, `undefined` to `None` |
| `unwrap()` | `(Optional[T]) -> T` | Extracts value, panics if `undefined` |

Sources: `src/js/pkg.generated.mbti:60-67`

## Union Types

The FFI layer provides `Union2` through `Union8` types for TypeScript-style union types, enabling type-safe handling of JavaScript APIs that can return multiple distinct types.

```mermaid
graph TB
    subgraph "Union Type Pattern"
        Union2["Union2[A, B]"]
        Union3["Union3[A, B, C]"]
        Union4["Union4[A, B, C, D]"]
        UnionMore["... Union5-8"]
    end
    
    subgraph "Construction Methods"
        From0["from0(A) -> Union"]
        From1["from1(B) -> Union"]
        From2["from2(C) -> Union"]
        FromN["fromN(...) -> Union"]
    end
    
    subgraph "Extraction Methods"
        To0["to0(Union) -> A?"]
        To1["to1(Union) -> B?"]
        To2["to2(Union) -> C?"]
        ToN["toN(Union) -> ...?"]
    end
    
    From0 --> Union2
    From1 --> Union2
    From0 --> Union3
    From1 --> Union3
    From2 --> Union3
    From0 --> Union4
    From1 --> Union4
    From2 --> Union4
    
    Union2 --> To0
    Union2 --> To1
    Union3 --> To0
    Union3 --> To1
    Union3 --> To2
    Union4 --> To0
    Union4 --> To1
    Union4 --> To2
```

**Union Type Construction and Extraction Pattern**

Sources: `src/js/pkg.generated.mbti:81-163`

### Union Type Usage Pattern

Each union type provides:
- **Construction methods** `from0` through `fromN`: Create a union from one of its variant types
- **Extraction methods** `to0` through `toN`: Attempt to extract a specific variant, returning `Some(value)` on success or `None` if the union holds a different variant

All variant types must implement the `Cast` trait for type-safe conversion with JavaScript values.

Example type signatures:
```
Union2[A : Cast, B : Cast]
  from0(A) -> Union2[A, B]
  from1(B) -> Union2[A, B]
  to0(Union2[A, B]) -> A?
  to1(Union2[A, B]) -> B?
```

Sources: `src/js/pkg.generated.mbti:81-93`

## Symbol Type

The `Symbol` type represents JavaScript's `Symbol` primitive for creating unique property keys.

```mermaid
graph LR
    subgraph "Symbol Construction"
        MakeDefault["Symbol::make()"]
        MakeNumber["Symbol::make_with_number(Double)"]
        MakeString["Symbol::make_with_string(String)"]
        MakeStringJS["Symbol::make_with_string_js(String)"]
        
        MakeDefault --> Symbol["Symbol"]
        MakeNumber --> Symbol
        MakeString --> Symbol
        MakeStringJS --> Symbol
    end
    
    subgraph "Well-Known Symbols"
        Iterator["iterator"]
        AsyncIterator["async_iterator"]
    end
    
    Iterator -.->|type is| Symbol
    AsyncIterator -.->|type is| Symbol
```

**Symbol Construction Methods**

The FFI layer exposes two well-known symbols as global constants:
- `iterator`: The `Symbol.iterator` well-known symbol
- `async_iterator`: The `Symbol.asyncIterator` well-known symbol

Sources: `src/js/pkg.generated.mbti:11-12`, `src/js/pkg.generated.mbti:19`, `src/js/pkg.generated.mbti:75-79`

## Error Handling

The `Error_` type represents JavaScript errors as a MoonBit error variant.

```mermaid
graph TB
    subgraph "Error Hierarchy"
        Error["Error trait"]
        Error_ ["Error_<br/>(suberror Value)"]
        
        Error_ -.->|"suberror of"| Error
    end
    
    subgraph "Error_ Methods"
        Cause["cause() -> Value?"]
        Output["output(&Logger)"]
        ToString["to_string() -> String"]
        Wrap["wrap[T](<br/>  () -> Value,<br/>  map_ok? : (Value) -> T<br/>) -> T raise Error_"]
    end
    
    Error_ --> Cause
    Error_ --> Output
    Error_ --> ToString
    Error_ --> Wrap
    
    subgraph "JavaScript Error"
        JSError["JavaScript Error object"]
    end
    
    JSError -.->|wraps| Error_
```

**Error_ Type and Methods**

The `Error_` type wraps a JavaScript error as a MoonBit `Error` subtype. It provides:
- `cause()`: Retrieves the underlying error cause
- `wrap()`: Executes a function that returns a JavaScript value, converting errors to `Error_`

Sources: `src/js/pkg.generated.mbti:28-33`

## Promise Integration

The `Promise` type enables async operations with JavaScript promises. For comprehensive documentation on async patterns, see [Asynchronous Operations](#3.1.1).

```mermaid
graph TB
    subgraph "Promise Construction"
        UnsafeNew["Promise::unsafe_new[T]<br/>(async () -> T) -> Promise"]
    end
    
    subgraph "Promise Operations"
        Wait["Promise::wait(Promise)<br/>async -> Value"]
        All["Promise::all(Array[Promise])<br/>-> Promise"]
    end
    
    subgraph "Helper Functions"
        Suspend["suspend[T, E : Error]<br/>((T -> Unit, E -> Unit) -> Unit)<br/>async -> T raise E"]
        AsyncRun["async_run<br/>(async () -> Unit noraise) -> Unit"]
        SpawnDetach["spawn_detach[T, E : Error]<br/>(async () -> T raise E) -> Unit"]
        AsyncAll["async_all[T]<br/>(Array[async () -> T])<br/>async -> Array[T]"]
    end
    
    UnsafeNew --> Promise["Promise<br/>(external type)"]
    Promise --> Wait
    Promise --> All
    
    Suspend -.->|"used by"| Wait
    AsyncRun -.->|"executes"| Promise
    SpawnDetach -.->|"fire and forget"| Promise
    AsyncAll -.->|"uses"| All
```

**Promise Type and Async Helper Functions**

Sources: `src/js/pkg.generated.mbti:69-74`, `src/js/async.mbt:1-76`

### Key Async Functions

| Function | Signature | Purpose |
|----------|-----------|---------|
| `suspend` | `async ((T) -> Unit, (E) -> Unit) -> Unit) -> T raise E` | Converts callback-based async to async/await |
| `async_run` | `(async () -> Unit noraise) -> Unit` | Executes async function in JavaScript event loop |
| `spawn_detach` | `(async () -> T raise E) -> Unit` | Starts async operation without waiting for result |
| `async_all` | `(Array[async () -> T]) -> Array[T]` | Executes multiple async operations concurrently |

Sources: `src/js/pkg.generated.mbti:9-25`, `src/js/async.mbt:2-75`

## Common FFI Patterns

### Pattern 1: JavaScript Function Invocation

```mermaid
sequenceDiagram
    participant MBT as "MoonBit Code"
    participant Value as "Value"
    participant JS as "JavaScript Runtime"
    
    MBT->>Value: globalThis (Value)
    Value->>Value: get_with_string("require")
    Value->>Value: apply(["http"])
    Value-->>MBT: Value (http module)
    MBT->>Value: get_with_string("createServer")
    Value->>Value: apply([callback])
    Value-->>MBT: Value (server instance)
```

**Calling JavaScript Functions from MoonBit**

This pattern is used throughout the JavaScript backend to call Node.js APIs. The `require` function at `src/js/pkg.generated.mbti:21` demonstrates this pattern for loading JavaScript modules.

Sources: `src/js/pkg.generated.mbti:21`, `src/js/pkg.generated.mbti:169`

### Pattern 2: Callback-Based to Async/Await

```mermaid
graph TB
    subgraph "JavaScript API"
        CallbackAPI["callback_api(<br/>  data,<br/>  (result) => {...},<br/>  (error) => {...}<br/>)"]
    end
    
    subgraph "MoonBit Async"
        Suspend["suspend(fn(k, ke) {<br/>  callback_api(<br/>    data,<br/>    fn(r) { k(r) },<br/>    fn(e) { ke(Error_(e)) }<br/>  )<br/>})"]
    end
    
    CallbackAPI -.->|"wraps"| Suspend
    Suspend --> AsyncValue["async -> T raise E"]
```

**Converting Callback-Based APIs to Async/Await**

The `suspend` function at `src/js/async.mbt:2-4` enables conversion of callback-based JavaScript APIs to MoonBit's async/await syntax. This pattern is used in `Promise::wait` at `src/js/async.mbt:29-31`.

Sources: `src/js/async.mbt:2-4`, `src/js/async.mbt:29-31`

### Pattern 3: Type-Safe Property Access

```mermaid
graph LR
    subgraph "Untyped Access"
        GetGeneric["value.get_with_string[Value](key)"]
    end
    
    subgraph "Type-Safe Access"
        Cast"Value::cast[TargetType"]
        GetTyped["value.get_with_string[TargetType](key)"]
    end
    
    subgraph "Object Wrapper"
        ObjGet["obj.op_get[String, TargetType](key)"]
    end
    
    GetGeneric --> Cast
    Cast --> Result["TargetType"]
    GetTyped --> Result
    ObjGet --> Result
```

**Type-Safe Property Access Patterns**

Sources: `src/js/pkg.generated.mbti:176-178`, `src/js/pkg.generated.mbti:56-57`

### Pattern 4: JSON Interop

The FFI layer provides bidirectional JSON conversion for seamless data exchange between MoonBit and JavaScript.

```mermaid
graph LR
    subgraph "MoonBit"
        Json["Json type<br/>(moonbitlang/core/json)"]
    end
    
    subgraph "JavaScript"
        JSValue["JavaScript value"]
    end
    
    subgraph "FFI Bridge"
        Value["Value"]
    end
    
    Json -->|"Value::from_json()"| Value
    Value -->|"Value::to_json()"| Json
    JSValue -.->|represents| Value
    
    JsonString["JSON String"] -->|"Value::from_json_string()"| Value
    Value -->|"Value::to_json_string()"| JsonString
```

**JSON Conversion Flow**

The example at `src/js/object_test.mbt:4` demonstrates creating an Object from JSON using `@json.from_json()` followed by `Object::from_value_unchecked()`.

Sources: `src/js/pkg.generated.mbti:174-175`, `src/js/pkg.generated.mbti:194-195`, `src/js/object_test.mbt:3-8`